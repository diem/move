#[actor]
module 0x44::IncrDecrFuture {

    use Jazz::Future::{Future, Cont, yield, followed_by};

    const MAX: u64 = 43;

    #[state]
    struct State {
        value: u64
    }

    #[init]
    fun init(): State {
        State{value: 0}
    }

    #[message]
    fun incr(this: &mut State, v: u64): Future<bool> {
        if (MAX - this.value < v)
            yield(false)
        else {
            this.value = this.value + v;
            yield(true)
        }
    }

    #[message]
    fun decr(this: &mut State, v: u64): Future<bool> {
        if (this.value < v)
            yield(false)
        else {
            this.value = this.value - v;
            yield(true)
        }
    }

    #[message]
    fun xfer(_this: &State, dest: address, v: u64): Future<bool> {
        followed_by(send_incr(dest, v), cont_xfer_decr(v))
    }

    #[continuation]
    fun xfer_decr(this: &mut State, v: u64, status: bool): Future<bool> {
        if (status) {
            decr(this, v)
        } else {
            yield(false)
        }
    }

    // ===============================================================
    // The following native function definitions are automatically
    // generated by a Move attribute preprocessor. That preprocessor
    // will also generate native implementations for those functions.

    #[generated_by_jazz]
    public native fun send_incr(dest: address, v: u64): Future<bool>;

    #[generated_by_jazz]
    native fun cont_xfer_decr(v: u64): Cont<bool, bool>;
}

/// Jazz supporting modules.
module Jazz::Future {

    /// A type which represents a future.
    native struct Future<T> has drop;

    /// A type which represents a continuation.
    native struct Cont<T, R> has drop;

    /// Yield execution to the given continuation.
    public native fun yield<T>(result: T): Future<T>;

    /// Yield a future which first executes `f`, then continues with `cont`.
    public native fun followed_by<T, R>(f: Future<T>, c: Cont<T, R>): Future<R>;
}
