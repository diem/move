#[actor]
module 0x44::IncrDecr {

    use Jazz::Cont::{Cont, yield};

    const MAX: u64 = 43;

    #[state]
    struct State {
        value: u64
    }

    #[init]
    fun init(): State {
        State{value: 0}
    }

    #[message]
    fun incr(this: &mut State, v: u64, cont: Cont<bool>) {
        if (MAX - this.value < v)
            yield(cont, false)
        else {
            this.value = this.value + v;
            yield(cont, true)
        }
    }

    #[message]
    fun decr(this: &mut State, v: u64, cont: Cont<bool>) {
        if (this.value < v)
            yield(cont, false)
        else {
            this.value = this.value - v;
            yield(cont, true)
        }
    }

    #[message]
    fun xfer(_this: &State, dest: address, v: u64, cont: Cont<bool>) {
        send_incr(dest, v, cont_xfer_decr(v, cont))
    }

    #[continuation]
    fun xfer_decr(this: &mut State, v: u64, cont: Cont<bool>, status: bool) {
        if (status) {
            decr(this, v, cont)
        } else {
            yield(cont, false)
        }
    }

    // ===============================================================
    // The following native function definitions are automatically
    // generated by a Move attribute preprocessor. That preprocessor
    // will also generate native implementations for those functions.

    #[generated_by_jazz]
    public native fun send_incr(dest: address, v: u64, cont: Cont<bool>);

    #[generated_by_jazz]
    native fun cont_xfer_decr(v: u64, cont: Cont<bool>): Cont<bool>;
}

/// Jazz supporting modules.
module Jazz::Cont {

    /// A type which represents a continuation.
    native struct Cont<T> has drop;

    /// Yield execution to the given continuation.
    public native fun yield<T>(cont: Cont<T>, result: T);
}
